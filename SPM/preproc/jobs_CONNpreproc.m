function job = jobs_CONNpreproc(arg1, arg2, par)
%
% Usage:
%   jobs_CONNpreproc(ffunc, fanat, par)
%   jobs_CONNpreproc('connprojet.mat',par)
%   jobs_CONNpreproc(connprojet.mat)
%
%
% Inputs:
%   ffunc - cellstr func file path
%         use get_sub file to get runs (sessions)
%   fanat - cellstr T1 file path
%   par   - struct of parameters (must be named par)
%
% If a .mat file is provided, it must generated by CONN
%
%
% par.batch
% Allows advanced users to override or extend specific parameters
% This lets advanced users modify or extend the CONN batch without changing the core function.
% e.g : add atlas
%        par.batch.Setup.rois.files{1} ='ROIs/AndyROIs.nii';
%        par.batch.Setup.rois.multiplelabels = 1;
%   Note that, If you define fields in par.batch, they will replace the default settings for those fields.
%   To learn more on those fields see :   https://web.conn-toolbox.org/resources/conn-documentation/conn_batch
%
%
% This function first creates a one job to be run on the cluster terminal,
% which launches MATLAB and executes the conn_batch command configured to create and automatically run individual jobs.
%
%
% To monitor the execution progress or check for errors, review the stdlog or stderr files located in the "[par.outname '.qlog']" subfolder,
% found inside the project’s main directory (oe same folder as the main .mat file).
%
%
%
%--------------------------------------------------------------------------
if ~exist('par'), par = ''; end


defpar.StudyMainFolder = '' ;  % <---- USER DEFINED: Path to the main folder where to put mat file
defpar.outname         = 'conn_project01';           % name of the output

defpar.sge      = 1;
defpar.jobname  = 'CONNJOBs';
defpar.walltime = '24';
defpar.mem      = '16G';
defpar.sge_nb_coeur  = 4;



defpar.TR = []    %
defpar.sliceorder = '';    % 'ascending',  'descending','interleaved (middle-top)','interleaved (bottom-up)','interleaved (top-down)',
%                            'interleaved (Siemens)','interleaved (Philips)','BIDS' (this option reads slice timing information from .json files)
%                             alternatively sliceorder may also be defined as a vector containing the acquisition time in
%                             milliseconds for each slice )
%

% defpar.nsessions   = [];
% defpar.nconditions = [];
defpar.optingui       = 1;   % 1/0   1 if your option are defined with GUI
defpar.fwhm           = 8;
defpar.preproc_steps  = {'functional_label'; 'functional_center';'functional_slicetime';'functional_realign'; 'structural_center'	; 'functional_segment&normalize_indirect'; 'structural_mask';'functional_smooth'}%
defpar.voxelsize_anat = 1.5;
defpar.voxelsize_func = 1.5;
defpar.overwrite = 0; % 0 :No, 1: Yes



par = complet_struct(par,defpar);

clear batch;
if nargin <= 2 && endsWith(arg1, ".mat")
    
    fmat  =  char(arg1);
    batchname = load(fmat);
    NSUBJECTS = batchname.CONN_x.Setup.nsubjects;
    batch.filename = fmat;
    %     filename = batch.CONN_x.filename;
    if ~par.optingui
        batch.Setup.preprocessing.steps          = par.preproc_steps;
        batch.Setup.preprocessing.sliceorder     = par.sliceorder;
        batch.Setup.preprocessing.fwhm           = par.fwhm;
        batch.Setup.preprocessing.voxelsize_anat = par.voxelsize_anat;
        batch.Setup.preprocessing.voxelsize_func = par.voxelsize_func;
    end
    
elseif nargin >= 2 && all(endsWith(arg1, '.nii'))
    
    
    ffunc = arg1;
    fanat = arg2;
    
    
    nsessions   = 1; % par.nsessions;
    nconditions = 1; % par.nconditions;
    NSUBJECTS  = length(ffunc);
    ffunc=reshape(ffunc,[nsessions, NSUBJECTS]);
    fanat=fanat';
    %     if isempty(nsessions)
    %          nsessions  = length(ffunc(1));
    %     end
    
    if rem(length(fanat),NSUBJECTS),error('Mismatch number of anatomical files %n', NSUBJECTS);end
    
    
    
    if isempty(par.StudyMainFolder)
        par.StudyMainFolder  =  get_commonPath(fanat);    % common Path
    end
    

    
    batch.filename= fullfile(par.StudyMainFolder,[par.outname '.mat']);  % New conn_*.mat experiment name
    % filename = batch.filename;
    batch.Setup.RT= par.TR;  % TR (seconds)
    
    batch.Setup.isnew       = 1;
    batch.Setup.nsubjects   = NSUBJECTS;
    batch.Setup.functionals = repmat({{}},[NSUBJECTS,nsessions]);       % Point to functional volumes for each subject/session
    
    for nsub=1:NSUBJECTS
        for nses=1:nsessions
            batch.Setup.functionals{nsub}{nses}{1} = ffunc{nses,nsub};
        end
    end %note: each subject's data is defined by three sessions and one single (4d) file per session
    
    batch.Setup.structurals = fanat; % Point to anatomical volumes for each subject
    
    
    if nconditions==1
        batch.Setup.conditions.names={'rest'};
        for ncond=1,for nsub=1:NSUBJECTS,for nses=1:nsessions,              batch.Setup.conditions.onsets{ncond}{nsub}{nses}=0; batch.Setup.conditions.durations{ncond}{nsub}{nses}=inf;end;end;end     % rest condition (all sessions)
    else
        batch.Setup.conditions.names=[{'rest'}, arrayfun(@(n)sprintf('Session%d',n),1:nconditions,'uni',0)];
        for ncond=1,for nsub=1:NSUBJECTS,for nses=1:nsessions,              batch.Setup.conditions.onsets{ncond}{nsub}{nses}=0; batch.Setup.conditions.durations{ncond}{nsub}{nses}=inf;end;end;end     % rest condition (all sessions)
        for ncond=1:nconditions,for nsub=1:NSUBJECTS,for nses=1:nsessions,  batch.Setup.conditions.onsets{1+ncond}{nsub}{nses}=[];batch.Setup.conditions.durations{1+ncond}{nsub}{nses}=[]; end;end;end
        for ncond=1:nconditions,for nsub=1:NSUBJECTS,for nses=ncond,        batch.Setup.conditions.onsets{1+ncond}{nsub}{nses}=0; batch.Setup.conditions.durations{1+ncond}{nsub}{nses}=inf;end;end;end % session-specific conditions
    end
     
    batch.Setup.preprocessing.steps          = par.preproc_steps;
    batch.Setup.preprocessing.sliceorder     = par.sliceorder;
    batch.Setup.preprocessing.fwhm           = par.fwhm;
    batch.Setup.preprocessing.voxelsize_anat = par.voxelsize_anat;
    batch.Setup.preprocessing.voxelsize_func = par.voxelsize_func;
    
else
    error("Usage: myPipeline(ffunc, fanat, par) OR myPipeline(config.mat, par)");
end

batch.Setup.done      = 0;
batch.Setup.overwrite = par.overwrite;
batch.Preprocessing.done = 0;

%%%
walltime = '';
if ~isempty(par.walltime)
    hh = str2num(par.walltime(1:2));
    dday = fix(hh/24);
    hh = rem(hh,24);
    walltime = sprintf(' -t %d-%.2d%s ',dday,hh,par.walltime(3:end));
    
end
mem = '--mem=16G';
if ~isempty(par.mem)
    mem = [' --mem=' par.mem ' '];
end

if isempty(par.sge_nb_coeur)
    sge_nb_coeur ='';
else
    sge_nb_coeur = [' --cpus-per-task=' num2str(par.sge_nb_coeur) ' '];
end

if par.sge
    
    job = {}
    batch.parallel.N       = NSUBJECTS;
    batch.parallel.profile = 'Slurm';
    batch.parallel.immediatereturn = 1;
    batch.parallel.cmd_submitoptions = [walltime mem sge_nb_coeur];
    
    % Expert mode modifications
    if isfield(par, 'batch')
        custom_fields = fieldnames(par.batch);
        
        for inde = 1:numel(custom_fields)
            f = custom_fields{inde};
            batch.(f) = par.batch.(f);   % écrase / ajoute le champ dans batch
        end
    end
    
    
    codejobs =  gencode(batch, 'batch')';
    codejobs{end+1}  = sprintf('\nconn_batch(batch);\n');
    
    
    job{end+1} = codejobs;
    do_cmd_matlab_sge(job, par);
    
    if isfield(par,'jobdir')
        fqsub = fullfile(par.jobdir, [par.jobname '/do_qsub.sh']);
    else
        fqsub = fullfile(pwd, [par.jobname '/do_qsub.sh']);
    end
    [~, fjob] = get_parent_path(get_file_from_same_dir(fqsub,'^j'));
    unix(sprintf('echo bash %s > %s',  fjob{end},  fqsub));
    
else
    
    batch.Setup.done = 1;
    batch.Preprocessing.done = 1;
    
    % Expert mode modifications
    if isfield(par, 'batch')
        custom_fields = fieldnames(par.batch);
        
        for inde = 1:numel(custom_fields)
            f = custom_fields{inde};
            batch.(f) = par.batch.(f);   % écrase / ajoute le champ dans batch
        end
    end
    
    
    conn_batch(batch);
    
    
end

end



function commonPath = get_commonPath(pathdir)

splitFolders = cellfun(@(p) strsplit(p, filesep), pathdir, 'UniformOutput', false);
commonPath   = '/';


for inde = 1:min(cellfun(@numel, splitFolders))
    segment = splitFolders{1}{inde};
    if all(cellfun(@(x) strcmp(x{inde}, segment), splitFolders))
        commonPath = fullfile(commonPath, segment);
    else
        break
    end
end

if isfile(commonPath)
    commonPath = get_parent_path(commonPath)
end

end